import 'dart:io';import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../../../data/exceptions/empty_list_exception.dart';import '../../../../../presentationUser/common/common_state.dart';import '../../../../../shared/models/common_list_item.dart';import '../../../../projectsManagement/data/datasource/projects_management_provider.dart';import '../../../../usersManagement/data/repositories/users_management_repository.dart';import '../../../../usersManagement/domain/entities/company.dart';import '../../../data/models/accept_or_reject_attachment_emp_prams.dart';import '../../../data/models/index.dart';import '../../../data/models/requirement_attachment_prams.dart';import '../../../domain/entities/AttachmentsEmp.dart';import '../../../domain/entities/EmployeeChasfiterDetails.dart';import '../../../domain/entities/index.dart';@Injectable()class AddNewEmployeesCubit extends BaseCubit {  final EmployeesRepository _repository;  AddNewEmployeesCubit(      this._repository, this.projectsManagementAPI, this.usersRepository);  final ProjectsManagementAPI projectsManagementAPI;  final UsersManagementRepository usersRepository;  StreamStateInitial<List<ShiftEmployee>?> shiftsStream = StreamStateInitial();  StreamStateInitial<List<PaymentPeriodTypes>?> paymentPeriodTypesStream =      StreamStateInitial();  StreamStateInitial<List<EmployeeStatuses>?> employeeStatusesStream =      StreamStateInitial();  StreamStateInitial<List<CommonListItem>?> projectsStream =      StreamStateInitial();  StreamStateInitial<List<EmployeeDataEntity>?> employeeDataEntityStream =      StreamStateInitial();  Future<void> fetchShiftByListProjectId(int projectIds) async {    try {      print('projectIds $projectIds');      final response = await _repository.fetchShiftsByProjects(projectIds);      final paymentPeriod =          await _repository.fetchPaymentPeriodTypesByProject(projectIds);      final employeeStatuses =          await _repository.fetchEmployeeStatusesByProject(projectIds);      List<ShiftEmployee> shifts =          response.map((e) => ShiftEmployee.fromDto(e)).toList();      List<PaymentPeriodTypes> PaymentPeriodList =          paymentPeriod.map((e) => PaymentPeriodTypes.fromDto(e)).toList();      List<EmployeeStatuses> employeeStatusesList =          employeeStatuses.map((e) => EmployeeStatuses.fromDto(e)).toList();      shiftsStream.setData(shifts);      paymentPeriodTypesStream.setData(PaymentPeriodList);      employeeStatusesStream.setData(employeeStatusesList);    } catch (e) {      print('error $e');      shiftsStream.setError(e);      paymentPeriodTypesStream.setError(e);      employeeStatusesStream.setError(e);    }  }  Future<void> fetchProjectsCompanyId(int companyId) async {    try {      final data =          await usersRepository.fetchListProjectsByCompanyId(companyId);      projectsStream.setData(data);    }   catch (e) {      projectsStream.setError(e);    }  }  Future<void> fetchEmployee({String? search}) async {    executeBuilder(() => _repository.fetchEmployee(search),        onSuccess: (value) async {      final data = value.map((e) => EmployeeDataEntity.fromDto(e)).toList();      emit(Initialized<List<EmployeeDataEntity>>(data: data));    });  }  Future<void> fetchEmployeeStream({String? search}) async {    try {      final data = await _repository.fetchEmployee(search);      final initData = data.map((e) => EmployeeDataEntity.fromDto(e)).toList();      employeeDataEntityStream.setData(initData);    } catch (error) {      employeeDataEntityStream.setError(error);    }  }  Future<List<Company>> fetchCompanies() async {    final response = await projectsManagementAPI.fetchCompanies();    return response.payload!.map((e) => Company.fromDto(e)).toList();  }  fetchShiftsByProjects(prjectId) async {    try {      final response = await _repository.fetchShiftsByProjects(prjectId);      List<ShiftEmployee> shifts =          response.map((e) => ShiftEmployee.fromDto(e)).toList();      shiftsStream.setData(shifts);    } catch (erorr) {      shiftsStream.setError(erorr);    }  }  Future<void> fetchDataAdd() async {    executeBuilder(() => _repository.fetchProject(), onSuccess: (value) async {      final project = value.map((e) => ProjectEmployee.fromDto(e)).toList();      final days = await fetchDayRelax();      final companies = await fetchCompanies();      emit(InitializedAddEmployee(          project: project, days: days, companies: companies));    });  }  Future<List<DayRelax>> fetchDayRelax() async {    final result = await _repository.fetchDayRelax();    print(result);    final day = result.map((e) => DayRelax.fromDto(e)).toList();    return day;  }  fetchPaymentPeriodTypes(projectIds) async {    try {      final paymentPeriod =          await _repository.fetchPaymentPeriodTypesByProject(projectIds);      List<PaymentPeriodTypes> PaymentPeriodList =          paymentPeriod.map((e) => PaymentPeriodTypes.fromDto(e)).toList();      paymentPeriodTypesStream.setData(PaymentPeriodList);    } catch (erorr) {      paymentPeriodTypesStream.setError(erorr);    }  }  fetchEmployeeStatuses(projectIds) async {    try {      final employeeStatuses =          await _repository.fetchEmployeeStatusesByProject(projectIds);      List<EmployeeStatuses> employeeStatusesList =          employeeStatuses.map((e) => EmployeeStatuses.fromDto(e)).toList();      employeeStatusesStream.setData(employeeStatusesList);    } catch (erorr) {      employeeStatusesStream.setError(erorr);    }  }  Future<void> addEmployment(AddEmployeePrameter params) async {    executeEmitterListener(() => _repository.addEditEmployee(          addEmployeePrameter: params,        ));  }  Future<void> addEditFreelancerAttachmentAdmin(      {required RequirementAttachmentPrams requirementAttachmentPrams,      required File file}) async {    executeEmitterListener(() => _repository.addEditFreelancerAttachmentAdmin(        requirementAttachmentPrams: requirementAttachmentPrams, file: file));  }  Future<void> addEditFreelancerAttachmentUser(      {required int requirementAttachmentId,      required File file}) async {    executeEmitterListener(() => _repository.AddEditFreelancerAttachmentUser(        requirementAttachmentId:  requirementAttachmentId, file: file));  }  // fetchAttachments({  int? freelancerId, int? statusCode,}) async {  //   executeBuilder(  //       () => _repository.fetchAttachments(freelancerId: freelancerId,statusCode: statusCode),  //       onSuccess: (value) async {  //     final data = value.map((e) => AttachmentsEmp.fromDto(e)).toList();  //     emit(Initialized<List<AttachmentsEmp>>(data: data));  //   });  // }  Future<void> acceptOrRejectAttachmentEmp(      {required AcceptOrRejectAttachmentEmpPrams acceptOrRejectAttachmentEmpPrams}) async {    executeEmitterListener(() => _repository.acceptOrRejectAttachmentEmp(        acceptOrRejectAttachmentEmpPrams ));  }  StreamStateInitial<List<AttachmentsEmp>?> attachmentsEmpStream = StreamStateInitial();  fetchAttachments({  int? freelancerId, int? statusCode,}) async {    attachmentsEmpStream.setData(null);    try {      final result = await _repository.fetchAttachments(freelancerId: freelancerId,statusCode: statusCode);      final data = result.map((e) => AttachmentsEmp.fromDto(e)).toList();      attachmentsEmpStream.setData(data);      if( data.isEmpty )   throw EmptyListException()  ;    }   catch (e) {      attachmentsEmpStream.setError(e);    }  }  fetchAttachmentsTabs({required int freelancerId}) async {    executeBuilder(() => _repository.fetchTabAttachment(), onSuccess: (result) {       fetchAttachments(statusCode: result.first.id!,freelancerId: freelancerId);      emit(Initialized<List<TabCashifter>>(data: result));    });  }  fetchEmpById({required int freelancerId}) async {    executeBuilder(        () => _repository.fetchEmpById(freelancerId: freelancerId),        onSuccess: (value) async {      final data = EmployeeChasfiterDetails.fromDto(value) ;      emit(Initialized<EmployeeChasfiterDetails>(data: data));    });  }}