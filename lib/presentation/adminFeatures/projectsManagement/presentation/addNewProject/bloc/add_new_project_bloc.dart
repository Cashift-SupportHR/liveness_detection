import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../../presentationUser/common/common_state.dart';import '../../../../../shared/components/files/files_manager.dart';import '../../../../addOpportunity/data/repositories/add_opportunity_repository.dart';import '../../../../addOpportunity/domain/entities/arrival_departure_type.dart';import '../../../../usersManagement/domain/entities/brand.dart';import '../../../data/models/index.dart';import '../../../domain/entities/index.dart';@Injectable()class AddNewProjectCubit extends BaseCubit {  final ProjectsManagementRepository _repository;  final AddOpportunityRepository oppRepository;  AddNewProjectCubit(this._repository, this.oppRepository);  Future<void> addEditNewProject(AddProjectParams params, {bool? isEdit}) async {    emit(LoadingStateListener());    try {      final response = await _repository.addEditNewProject(params);      if (isEdit == null) {        emit(SuccessStateListener<int>(data: response.payload));      } else {        emit(SuccessStateListener<String>(data: response.message.toString()));      }    } catch (e) {      print('error is ${e.toString()}');      emit(FailureStateListener(e));      rethrow;    }  }  Future<void> fetchAllaData({int? id}) async {    AddProjectParams projectInfoManager = AddProjectParams();    emit(LoadingState());    try {      projectInfoManager = (id == null || id == 0) ? AddProjectParams() : await fetchProjectInfoById(id);      final labels = await fetchProjectLabels();      final cities = await fetchCities();      final brands = await fetchListBrand();      final companies = await _repository.fetchCompanies();      final arrivalDepartureTypes = await fetchTypesArrivalDeparture();      emit(InitializedAddNewProject(projectInfoManager: projectInfoManager, labels: labels, cities: cities, brands: brands, company: companies, arrivalDepartureTypes: arrivalDepartureTypes));    } on Exception catch (e) {      emit(ErrorState(e));    }  }  Future<List<Brand>> fetchListBrand() async {    final response = await _repository.fetchListBrand();    List<Brand> brands = response.map((e) => Brand.fromDto(e)).toList();    return brands;  }  Future<List<City>> fetchCities() async {    final response = await _repository.fetchCities();    List<City> cities = response.map((e) => City.fromDto(e)).toList();    return cities;  }  Future<ProjectLabels> fetchProjectLabels() async {    final response = await _repository.fetchProjectLabels();    return ProjectLabels.fromDto(response);  }  Future<AddProjectParams> fetchProjectInfoById(int? id) async {    final response = await _repository.fetchProjectInfoById(id);    return response;  }  Future<String> deleteProject(int? id) async {    final response = await _repository.deleteProject(id);    return response;  }  Future<List<ArrivalDepartureType>>  fetchTypesArrivalDeparture() async {    final data = await oppRepository.fetchTypesArrivalDeparture();    final arrivalDepartureTypes =    data.map((e) => ArrivalDepartureType.fromDto(e)).toList();    return arrivalDepartureTypes;  }}